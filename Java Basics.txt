JAVA is a complete package of JDK(Java Development KIt) -> JRE(Java Runtime Environment) -> JVM(Java Virtual Machine) - > JIT(Just In Time Compiler).

So If I have craeted a .java file(my code), then below is the flow of how my .java code turns into my output expected:
   1. JDK contains Java compiler(javac), JRE. So the first step after creting a .java file, is to compile it. This is done by executing the command "javac Sample.java" in a CMD. Here, the compiler of   JDK will compile the java code and convert it into byte code(.class file). So this byte code is platform independent(independent of OS). So, a class file generated in windows system can be runned in a linux system.
   2. JRE actually provides an environment for running the java files. JVM, which is present inside JRE is responsible for running the byte code. If first loads the class file(Sample.class) into memory and loads necessary java libraries. And also it allocates memory for the variables inside the java code in the heap. Next it verifies if the class file is safe(without any error, if so, they are called runtime errors). It is also responsible for replacing teh actual values for the input variables, when the input(actual values) is provided. I contains stack and heap allocations.
   3. Now, the JIT compiles blocks of byte code, converts it into machine code and caches it, for better performance. 	   
   
1. If a java file name is "Sample.java", then the file contains "Sample" public class. the only public class that shoul be present in Sample.java.
2. Usually calss name should be starting with a capital letter.
3. A public class can be accessed from anywhere in any class,any file and any package.
4. public static void main(String[] args){
} is the main method of the java where the code starts from. here public means that the JVM executes the main method first outside the class, so it has to be accesible, so that is the reason "Main" method is public. static is a way of saying that the main method is dependent on any instance of teh class but the class itself. Since, main method is the start point even b4 anything, should be instance independent, that is the reason main method is static. void because the method does not return anything. String args[] is the para,eters for the main method, so that the JVM can pass the comman-line arguments to main method. Eg: "java Sample Hello Hi Bye"(java run command). Now args array contains Hello, Hi and Bye as array input.
5. System.ot.println, here the System class is the java's default class present in java.langh package that helps to deal with debugging , output etc.Syste.out is the dispaly of output and System.in is the input from keyboard.
6. Scanner calss helps to get the user defined output from the console. Eg:
Scanner sc = new Scanner(System.in);
int a = sc.nextInt();

Here if the input is string then String b = sc.next(). But we have to observe that, if in console if i type Hey How are you, then b contains only Hey, because it considers only sing string until the space. If we want the entire line then we have to go for String a = sc.netLine()
7. Datatypes in java: Primitive and Non-primitive.
8. Primitive: They are simple datatypes where it cannot be divided or break further.Eg: nuber 4 or character a etc. Integer(4 bytes), Character,float(4 bytes),double(8 bytes),long(8 bytes),boolean.
int a =10;
float f = 1.1f;
char a = "k";
double d = 4567.09998
long l = 1098787987987L;
boolean b = false;

Ok, nowhy do we add f and L at the end of floaat and long? actually the equivalent datatypes of long and float are int and double. The difference is Long accepts larger number(in terms of size 8 bytes) and float has leseer precision. So,
Eg1: float 1.1; -> for java, this 1.1 is by default double. So if we compile this, it will throw a compilation error saying lousy conversion. so we need to tell java explicitly that 1.1 is a float despite of declaring it as a float, as 'f'. Eg2: long b = 0989789789787; For java 0989789789787 is int by default so when we compile it it throws an error saying too large number since integer can only store 4 bytes. so we need to tell java explicitly that 0989789789787 is a long despite of declaring it as a long, as 'L'.

8. Automatic Type casting in java without being done explicitly will work under certain conditions. Eg: Assigning an integer to a float. float a = 4; This will work because float and integer are compatabile and also, we are assigning a comparitively small datatype(int) to float, but this will not work the other way around. If we want t o assign a float to integer the we need to do type casting explicitly. Eg: int a = (int) 45.2;

Eg1:
int a=345;
byte b = (byte) a;

Now b will store 89. why? - a byte can store atmost 256 bits so the value that is greater than 256 will be divided by 256 and the remainder will be stored in a byte variable, if a larger number is assigned. This only happen if the type casting is done. In normal, you cannot do byte b = 456; this will give type mismatch error, since 456 is considered as int.

Eg2:
byte a = 9;
byte c=5;
byte c=a*b; -> this will throw type mismatch error.
Why? - This is because when complex function are involved(+,-,*,/) between two bytes, the the result will be casted automatically to int. So the result cannot be stored in a byte variable.

9. Java works on UNICODE values, meaning it supports all the languages.
10. In java, when two different data types are packed with an operator, the the result of the operation will in the dtatype that superior of the both datatypes. Eg: int,float = float. int,long=long. Thease are known as type promotion rules of java.

9. Non-Primitive: 
 

   